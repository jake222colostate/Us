import { useCallback, useState } from 'react';
import { Platform } from 'react-native';
import * as FileSystem from 'expo-file-system/legacy';
import * as Crypto from 'expo-crypto';
import type { ImagePickerAsset } from 'expo-image-picker';
import { Buffer } from 'buffer';
import { getSupabaseClient } from '../api/supabase';
import {
  mapPhotoRow,
  type PhotoRow,
  POST_PHOTO_BUCKET,
  type PhotoResource,
  type ModerationStatus,
} from '../lib/photos';
import {
  useAuthStore,
  selectCurrentUser,
  selectIsPremium,
  selectSession,
} from '../state/authStore';
import { usePostQuotaStore } from '../state/postQuotaStore';

const FALLBACK_TYPE = Platform.OS === 'ios' ? 'image/jpeg' : 'image/jpg';

type UploadPhotoArgs =
  | { asset: ImagePickerAsset }
  | { uri: string; mimeType?: string | null; width?: number | null; height?: number | null };

type UploadResult = {
  success: boolean;
  status?: ModerationStatus;
  photo?: PhotoResource;
};

type NormalizedAsset = {
  uri: string;
  mimeType?: string | null;
  fileName?: string | null;
  width?: number | null;
  height?: number | null;
};

function toBytes(base64: string): Uint8Array {
  if (typeof globalThis.atob === 'function') {
    const binary = globalThis.atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  const buffer = Buffer.from(base64, 'base64');
  return new Uint8Array(buffer);
}

function normalizeAsset(input: UploadPhotoArgs): NormalizedAsset {
  if ('asset' in input) {
    return {
      uri: input.asset.uri,
      mimeType: input.asset.mimeType ?? null,
      fileName: input.asset.fileName ?? null,
      width: input.asset.width ?? null,
      height: input.asset.height ?? null,
    };
  }
  return {
    uri: input.uri,
    mimeType: input.mimeType ?? null,
    fileName: input.uri.split('/').pop() ?? null,
    width: input.width ?? null,
    height: input.height ?? null,
  };
}

function guessContentType(asset: NormalizedAsset): string {
  if (asset.mimeType) return asset.mimeType;
  const fileName = asset.fileName ?? asset.uri.split('/').pop() ?? '';
  const extension = fileName.split('.').pop()?.toLowerCase();
  if (!extension) return FALLBACK_TYPE;
  if (extension === 'png') return 'image/png';
  if (extension === 'webp') return 'image/webp';
  if (extension === 'heic' || extension === 'heif') return 'image/heic';
  return `image/${extension}`;
}

function ensureUuid(): string {
  if (typeof globalThis.crypto?.randomUUID === 'function') {
    return globalThis.crypto.randomUUID();
  }
  return Crypto.randomUUID();
}

export function usePhotoModeration() {
  const session = useAuthStore(selectSession);
  const user = useAuthStore(selectCurrentUser);
  const upsertPhoto = useAuthStore((state) => state.upsertUserPhoto);
  const removePhotoFromState = useAuthStore((state) => state.removeUserPhoto);
  const setPhotos = useAuthStore((state) => state.setUserPhotos);
  const isPremium = useAuthStore(selectIsPremium);
  const { canPost, markPosted } = usePostQuotaStore((state) => ({
    canPost: state.canPost,
    markPosted: state.markPosted,
  }));
  const [isUploading, setIsUploading] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadPhotos = useCallback(async () => {
    if (!session) return;
    setIsRefreshing(true);
    try {
      const client = getSupabaseClient();
      const { data, error: listError } = await client
        .from('photos')
        .select('*')
        .eq('user_id', session.user.id)
        .order('created_at', { ascending: false });
      if (listError) throw listError;
      const mapped = await Promise.all(((data ?? []) as PhotoRow[]).map((row) => mapPhotoRow(row)));
      setPhotos(mapped);
    } catch (err) {
      console.error(err);
      setError('Unable to load photos from Supabase.');
    } finally {
      setIsRefreshing(false);
    }
  }, [session, setPhotos]);

  const uploadPhoto = useCallback(
    async (input: UploadPhotoArgs): Promise<UploadResult> => {
      if (!session) {
        setError('Sign in to upload photos.');
        return { success: false };
      }

      const dailyLimit = isPremium ? 20 : 3;
      if (!canPost(dailyLimit)) {
        setError(`You reached your daily limit of ${dailyLimit} uploads. Upgrade to share more.`);
        return { success: false };
      }

      const asset = normalizeAsset(input);
      if (!asset.uri) {
        setError('Choose a valid photo to upload.');
        return { success: false };
      }

      setIsUploading(true);
      setError(null);

      const contentType = guessContentType(asset);
      const extension = contentType.split('/')[1] || 'jpg';
      const path = `${session.user.id}/${ensureUuid()}.${extension}`;
      const optimisticId = ensureUuid();

      const optimisticPhoto: PhotoResource = {
        id: optimisticId,
        storagePath: path,
        status: 'pending',
        url: asset.uri,
        contentType,
        width: asset.width ?? null,
        height: asset.height ?? null,
        rejectionReason: null,
        localUri: asset.uri,
      };

      upsertPhoto(optimisticPhoto);
      let optimisticActive = true;

      try {
        const client = getSupabaseClient();
        const base64 = await FileSystem.readAsStringAsync(asset.uri, {
          encoding: FileSystem.EncodingType.Base64,
        });
        const bytes = toBytes(base64);

        const { error: uploadError } = await client.storage
          .from(POST_PHOTO_BUCKET)
          .upload(path, bytes, { contentType, upsert: false });
        if (uploadError) {
          throw uploadError;
        }

        const { data: publicUrlData } = client.storage.from(POST_PHOTO_BUCKET).getPublicUrl(path);
        const publicUrl = publicUrlData?.publicUrl;
        if (!publicUrl) {
          throw new Error('Unable to resolve uploaded photo URL');
        }

        const basePayload: Record<string, unknown> = {
          user_id: session.user.id,
          url: publicUrl,
          content_type: contentType,
          status: 'pending',
        };

        if (typeof asset.width === 'number') {
          basePayload.width = asset.width;
        }
        if (typeof asset.height === 'number') {
          basePayload.height = asset.height;
        }

        const attemptInsert = (payload: Record<string, unknown>) =>
          client.from('photos').insert(payload).select('*').single();

        let { data: inserted, error: insertError } = await attemptInsert(basePayload);

        if (insertError && (insertError.code === 'PGRST204' || insertError.code === '42703')) {
          console.warn('Photos table missing dimension columns, retrying insert without width/height');
          const fallbackPayload = { ...basePayload };
          delete fallbackPayload.width;
          delete fallbackPayload.height;
          const fallbackResult = await attemptInsert(fallbackPayload);
          inserted = fallbackResult.data;
          insertError = fallbackResult.error;
        }

        if (insertError || !inserted) {
          await client.storage.from(POST_PHOTO_BUCKET).remove([path]).catch(() => undefined);
          throw insertError ?? new Error('Unable to insert uploaded photo record');
        }

        if (optimisticActive) {
          removePhotoFromState(optimisticId);
          optimisticActive = false;
        }

        const mapped = await mapPhotoRow(inserted as PhotoRow);
        const nextPhoto: PhotoResource = { ...mapped, localUri: asset.uri };
        upsertPhoto(nextPhoto);
        markPosted();

        let finalStatus: ModerationStatus | undefined = nextPhoto.status;
        try {
          const { data: moderationData, error: moderationError } = await client.functions.invoke('moderate-photo', {
            body: { photoId: inserted.id, userId: session.user.id, publicUrl },
          });
          if (moderationError) {
            console.warn('moderate-photo invocation failed', moderationError);
          } else if (moderationData?.status) {
            finalStatus = moderationData.status as ModerationStatus;
            if (finalStatus && finalStatus !== nextPhoto.status) {
              upsertPhoto({ ...nextPhoto, status: finalStatus });
            }
          }
        } catch (invokeError) {
          console.warn('Failed to invoke moderation function', invokeError);
        }

        return {
          success: true,
          status: finalStatus ?? nextPhoto.status,
          photo: { ...nextPhoto, status: finalStatus ?? nextPhoto.status },
        };
      } catch (err) {
        console.error(err);
        if (optimisticActive) {
          removePhotoFromState(optimisticId);
        }
        setError('Upload failed. Try again when you are back online.');
        try {
          const client = getSupabaseClient();
          await client.storage.from(POST_PHOTO_BUCKET).remove([path]);
        } catch (cleanupError) {
          console.warn('Failed to clean up storage upload', cleanupError);
        }
        return { success: false };
      } finally {
        setIsUploading(false);
      }
    },
    [session, isPremium, canPost, upsertPhoto, removePhotoFromState, markPosted],
  );

  const refreshPhoto = useCallback(
    async (photoId: string) => {
      if (!session) return;
      setIsRefreshing(true);
      try {
        const client = getSupabaseClient();
        const { data, error: refreshError } = await client
          .from('photos')
          .select('*')
          .eq('id', photoId)
          .single();
        if (refreshError || !data) throw refreshError ?? new Error('Missing photo');
        const mapped = await mapPhotoRow(data as PhotoRow);
        upsertPhoto(mapped);
      } catch (err) {
        console.error(err);
        setError('Could not refresh moderation status.');
      } finally {
        setIsRefreshing(false);
      }
    },
    [session, upsertPhoto],
  );

  const removePhoto = useCallback(
    async (photoId: string) => {
      if (!session) return;
      const client = getSupabaseClient();
      const photo = user?.photos.find((item) => item.id === photoId);
      removePhotoFromState(photoId);
      try {
        if (photo?.storagePath) {
          await client.storage.from(POST_PHOTO_BUCKET).remove([photo.storagePath]);
        }
        await client.from('photos').delete().eq('id', photoId);
      } catch (err) {
        console.error(err);
        setError('Photo removed locally. It will sync once back online.');
      }
    },
    [session, user?.photos, removePhotoFromState],
  );

  const retryModeration = useCallback(
    async (photoId: string) => {
      console.warn('Manual moderation retry is not supported. Refreshing photo instead.');
      await refreshPhoto(photoId);
    },
    [refreshPhoto],
  );

  const approvePhoto = useCallback(async () => {
    setError('Manual approval is no longer supported.');
  }, []);

  const clearError = useCallback(() => setError(null), []);

  return {
    user,
    isUploading,
    isRefreshing,
    error,
    uploadPhoto,
    refreshPhoto,
    retryModeration,
    approvePhoto,
    removePhoto,
    loadPhotos,
    clearError,
  };
}
